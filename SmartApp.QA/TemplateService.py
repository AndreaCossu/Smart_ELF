import sys
from interface_tags import PATH_TO_KB_MODULE, TAG_USER_TRANSCRIPT, EXPANDED_RULE_FILE_NAME, TAG_ANSWER
sys.path.insert(0, PATH_TO_KB_MODULE)
from kb import KnowledgeBaseClient
from tree_templates.tree_matcher import match_tree
import logging
import json as json
import templates as tp
import datetime

"""
This service tries to match a template against the transcript of user query
generated by STT module
"""
class TemplateService:

    def __init__(self, kb_ID, logging_lvl):
        self.logging_lvl = logging_lvl
        self.kb_ID = kb_ID
        logging.basicConfig(stream=sys.stderr, level=logging_lvl)
        logging.info('\tTemplateService Service Handler created')
        self.kb_client = KnowledgeBaseClient(True)
        self.query_prof, self.q_prof_answ, self.query_corso, self.q_corso_answ,\
        self.dict_q_aule, self.dict_answ_aule = tp.init_templates_dict()

    def write_to_KB(self, fact, tag):
        """
        Post a tuple to the KB
        """
        self.kb_client.addFact(self.kb_ID, tag, 1, 100, fact)
        return

    def generate_query(self, *param):
        """This function is called by KB once a user ask a question.
           We'll try to match a template, and if we do, we push the associated
            predefined query to the KB
        """
        logging.info("\tCallback Template Service_thread called")
        query = self._get_query_from_kb(param)

        (success, tplt_query) = self.qa_exact_temp_matching(query)
        if (success==True):
            fact = {
                "tag": TAG_ANSWER,
                "query_text": tplt_query,
                "time_stamp": str(datetime.datetime.now())
            }
            self.write_to_KB(fact, TAG_ANSWER)
        else:
            logging.info("\tCan't match template. No data has been written to KB")

        """response = {
            "tag": TAG_ANSWER,
            "query_text": "Non ho capito. Puoi ripetere?",
            "time_stamp" : 1
        }
        self.write_to_KB(response,TAG_ANSWER)
        print('Default answer produced')"""

    def _get_query_from_kb(self, response):
        """Extract the user query from the kb response object"""
        answer_arr = response[0] # first field of the tuple.It contains the resp
        query = answer_arr["details"][0]["object"]["_data"]["text"]
        return query


    def qa_exact_temp_matching(self, input_q):
        """This function tries to match exactly the query of a user to a
        template. Templates are in templates.py file in this module
        If a match is found this function returns a tuple with the following
        format: (True/False, associated query)
        """

        logging.debug("\tInput query: " + input_q)
        # try to match
        res_1 = tp.check_exact_match(input_q, self.query_prof, self.q_prof_answ, ["professor", "professore", "prof"])
        if (res_1[0] is True):
            query = res_1[1]
            query = query.replace("<prof-placeholder>", res_1[3])
            """print("Sto per fare la query sulla kB")
            print(query)
            #query = '{"_data": {"tag" : "crawler_course"}}'
            query = json.loads(query)
            resp = self.kb_client.query(query)
            print(resp)"""
            return (True, query)
        else:
            res = tp.check_exact_match(input_q, self.query_corso, self.q_corso_answ, ["corso", "corso di"])
            if (res[0] == True):
                query = res_1[1]
                query = query.replace("<prof-placeholder>", res_1[3])
                """print("Sto per fare la query sulla kB")
                print(query)
                #query = '{"_data": {"tag" : "crawler_course"}}'
                query = json.loads(query)
                resp = self.kb_client.query(query)
                print(resp)"""
                return (True, query)
            else:
                res = tp.check_exact_match(input_q, self.query_corso, self.q_corso_answ, ["aula"])
                if (res[0] == True):
                    query = res_1[1]
                    query = query.replace("<prof-placeholder>", res_1[3])
                    """print("Sto per fare la query sulla kB")
                    print(query)
                    query = json.loads(query)
                    resp = self.kb_client.query(query)
                    print(resp)"""
                    return (True, query)
                else:
                    return (False, [])


    def start(self):
        """Subscribe and wait for data"""
        self.kb_client.subscribe(self.kb_ID, {"_data": {"tag": TAG_USER_TRANSCRIPT, "text": "$input"}}, self.generate_query)
        logging.info("\tTemplate Service started")


if __name__ == "__main__":

    global myID
    service_qa = QaService(myID,logging_lvl=logging.DEBUG)
    service_qa.start()
